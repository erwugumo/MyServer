RAII:
什么是RAII？

RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

为什么要使用RAII？

上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：
1 申请资源；
2 使用资源；
3 释放资源。
第一步和第三步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。

一个最简单的例子：
```cpp
#include <iostream> 
using namespace std; 
int main() 
{ 
    int *testArray = new int [10]; 
    // Here, you can use the array 
    delete [] testArray; 
    testArray = NULL ; 
    return 0; 
}
```

我们在用动态内存分配时，经常是用new来定义一块内存空间，比如说 int* p = new int(1)；这时会在堆上分配一块内存，当作int类型使用，内存中存储的值为1并将内存地址赋值给在栈中的int*类型的p。（注意：p只是一个变量，就像是int a=1中的a一样，不过a是整形变量，而p是指针变量）当我们不用p指针时，往往需要用delete p将其释放，我们需要注意的是释放一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了"空指针"。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句。

小结：
但是如果程序很复杂的时候，需要为所有的new 分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，怎么办？这个时候，RAII机制就可以派上用场了。

如何使用RAII?

当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就被销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。

由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。

使用RAII 机制的代码：
```cpp
#include <iostream> 
using namespace std; 
class ArrayOperation 
{ 
public : 
    ArrayOperation() 
    { 
        m_Array = new int [10]; 
    }  
    void InitArray() 
    { 
        for (int i = 0; i < 10; ++i) 
        { 
            *(m_Array + i) = i; 
        } 
    }  
    void ShowArray() 
    { 
        for (int i = 0; i <10; ++i) 
        { 
            cout<<m_Array[i]<<endl; 
        } 
    } 
    ~ArrayOperation() 
    { 
        cout<< "~ArrayOperation is called" <<endl; 
        if (m_Array != NULL ) 
        { 
            delete[] m_Array;  
            m_Array = NULL ; 
        } 
    } 
private : 
    int *m_Array; 
};  
bool OperationA(); 
bool OperationB(); 
int main() 
{ 
    ArrayOperation arrayOp; 
    arrayOp.InitArray(); 
    arrayOp.ShowArray(); 
    return 0;
}
```
在使用多线程时，经常会涉及到共享数据的问题，C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过这意味着必须记住在每个函数出口都要去调用unlock()，也包括异常的情况，这非常麻烦，而且不易管理。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造函数的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。上面的代码正式\<mutex>>头文件中的源码，其中还使用到很多C++11的特性，比如delete/noexcept等，有兴趣的同学可以查一下。

线程同步四项原则：
尽量最低限度的共享对象，减少需要同步的场合：一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行再暴露可修改的对象，使用同步措施来充分保护它。
使用高级的并发编程构建：TaskQueue、Producer-Consumer Queue、CountDownLatch等。
必须使用底层同步原语时，使用非递归的互斥器和条件变量，慎用读写锁，不用信号量。
除了使用atomic整数之外，不自己编写lock-free代码，不用内核级同步原语。

互斥器：
使用最多的同步原语，保护临界区，保证任意时刻最多只能有一个线程在此mutex划出的临界区活动。单独使用mutex主要为了保护共享数据。

使用RAII手法封装mutex的创建、销毁、加锁、解锁。保证锁的生效期间等于一个作用域。

只使用非递归的mutex。

不手工调用lock和unlock函数，一切交给栈上的Guard对象的构造和析构函数负责。Guard对象的生命期正好等于临界区。避免在foo里加锁，然后跑到bar里解锁。避免在不同的分支分别加锁解锁。

每次构造guard对象的时候，思考调用栈上已经持有的锁，防止因加锁顺序不同而导致死锁。

只使用非递归的mutex：

mutex分递归和非递归两种，也叫可重入和非可重入。它们作为线程间的同步工具时没有区别，唯一区别在于：同一个进程可以重复对递归的mutex加锁，但对非递归的mutex不能。在同一个进程里再次对非递归的mutex加锁将导致死锁。

使用递归的mutex可能会导致一些问题：
线程A调用函数a，先获取锁，然后改变对象foo；调用函数b，先获取锁，然后遍历vector\<foo>，遍历时调用a；这时，非递归的mutex由于两次调用而死锁，递归的mutex则不会。但是，若在遍历vector时执行了push_back，则可能导致迭代器失效，程序crash。

举这个例子是为了表示出非递归mutex可以一定程度上暴露出程序的逻辑错误：遍历vector的时候对vector进行了修改——对于非递归mutex，直接死锁，可以立即发现错误；对于非递归则只能在crash时候发现错误。

那怎么改呢？可以把修改推后，先记住哪些要修改，退出循环后再修改；或者copy-on-write。就是发现要修改，那么复制一个vector，在复制后的vector上修改，改完了用复制后的代替之前的。

如果一个函数既可能在加锁的情况下调用，又可能在不加锁的情况下调用，那么就拆成两个函数。

死锁：一般出现在多个mutex请求顺序不当的时候。
比如，进程A调用函数a，请求mutex1，然后遍历vector1，对每个vector1中的元素，请求元素中的mutex2，然后处理；此时又有进程B将vector中的元素进行销毁，销毁首先请求mutex2，然后请求mutex1将vector中的元素删除。这时进程A和进程B分别获得了mutex1和mutex2，造成死锁。

怎么解决呢？要不就准备一个vector的副本，printf处理，要不就用shared_ptr；但是都没有解决vector中的元素析构的话产生的竞态条件。

解决析构不但需要用shared_ptr管理vector，还需要用shared_ptr管理vector中的资源。

条件变量：
