一个新连接建立的完整过程：
首先，客户端向服务器端发起TCP握手请求。此时在Server的主循环中，有一个AcceptChannel，其中关联着lishenfd对应的socket。在listenfd对应的socket的未完成队列中，建立一个新连接。
三次握手之后，将新连接转移到已完成队列中。
AcceptChannel对应的Event是注册在主循环的Epoll池子中的，称为listenEvent。当已完成队列中有写入，epoll_wait函数发现listenEvent中写入数据，将listenEvent放入Epoll池子的rdlist中，等到等待时间结束把rdlist中的内容返回。
在主循环的Loop中，得到返回的listenEvent之后，通过fd2Channel得到AcceptChannel。根据这个注册的Event的属性，设定Channel的属性。然后根据AcceptChannel的属性，调用AcceptChannel的handleRead函数。
在handleRead函数中，调用accept函数，读取listenfd中的已完成队列，拿出新连接，构造一个新的socket，即acceptfd。
然后从loop池中拿出一个loop，用这个acceptfd和这个loop，构建一个httpData，这个httpData中有一个新的channel。
构造好之后，把httpData对应的newEvent函数加入到loop的函数数组中，注意这个loop不是Server的loop，是从loop池子中拿的loop。然后向这个loop的wakeupfd中写入一个字节，即调用wakeup函数。
在子线程中，loop一直在运行。当它的wakeupfd接收到一个字符，相当于Server的listenfd接受到写入，wakeupfd对应的Channel也有wakeupEvent，这个wakeupEvent注册在loop的Epoll中。这次这个Epoll把wakeupEvent拎出来。epoll_wait返回它。在loop对应的fd2Channel中，找到对应的Channel。之后也一样。调用这个wakeupChannel的hanleRead函数。从wakeupfd中读取一个字，就是上面写入的。然后调用wakeupChannel的handleconn函数。最后调用loop的函数数组中的函数，调用到newEvent，设置新连接对应的Channel属性，然后把新连接注册到loop对应的epoll中。完成连接。

Channel分三种：
AcceptChannel，只有一个，Server的主循环拥有的，封装着listenfd，用于接收新连接请求；
WakeupChannel，有四个，一个子线程的loop有一个，封装着wakeupfd，用于实现与主循环通信；
httpChannel，一个连接有一个，封装着acceptfd，用于服务器与客户端维持连接。
每种Channel的handle函数各不相同，各自完成各自功能。

为什幺要调用wakeup函数？这个函数实际上相当于通知线程，我给了你一个Channel，你要是没事可以开始处理它了。当该线程没有已连接的请求时，如果不wakeup，那么就永远在epoll_wait阻塞了，有了它，就可以退出epoll_wait开始处理连接。